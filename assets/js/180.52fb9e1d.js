(window.webpackJsonp=window.webpackJsonp||[]).push([[180],{662:function(r,a,t){"use strict";t.r(a);var n=t(5),e=Object(n.a)({},(function(){var r=this,a=r.$createElement,t=r._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("p",[r._v("[toc]")]),r._v(" "),t("h3",{attrs:{id:"比较擅长的一个项目？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#比较擅长的一个项目？"}},[r._v("🌙")]),r._v(" 比较擅长的一个项目？")]),r._v(" "),t("h3",{attrs:{id:"主要做的哪些模块？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主要做的哪些模块？"}},[r._v("🌙")]),r._v(" 主要做的哪些模块？")]),r._v(" "),t("h3",{attrs:{id:"vue里面的传值？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue里面的传值？"}},[r._v("🌙")]),r._v(" vue里面的传值？")]),r._v(" "),t("p",[r._v("（数据传递）父传子：props\n子传父：父组件里面定义事件，子组件通过$emit事件传参\n兄弟传参：事件总线（EventBus、Vuex）")]),r._v(" "),t("h3",{attrs:{id:"路由传参：params、query"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路由传参：params、query"}},[r._v("🌙")]),r._v(" 路由传参：params、query")]),r._v(" "),t("h3",{attrs:{id:"数组遍历的常用方法？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组遍历的常用方法？"}},[r._v("🌙")]),r._v(" 数组遍历的常用方法？")]),r._v(" "),t("p",[r._v("forEach、map、filter、find、every（数组中是否每个元素都满足指定的条件）、some（数组中是否有元素满足指定的条件）、reduce（将数组合成一个值）")]),r._v(" "),t("h4",{attrs:{id:"过滤？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#过滤？"}},[r._v("🌙")]),r._v(" 过滤？")]),r._v(" "),t("p",[r._v("filter、find")]),r._v(" "),t("h4",{attrs:{id:"foreach和map的区别？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#foreach和map的区别？"}},[r._v("🌙")]),r._v(" forEach和map的区别？")]),r._v(" "),t("p",[r._v("forEach()方法不会返回执行结果，而是undefined。也就是说，forEach()会修改原来的数组。而map()方法会得到一个新的数组并返回。")]),r._v(" "),t("h4",{attrs:{id:"对象可以用foreach吗？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象可以用foreach吗？"}},[r._v("🌙")]),r._v(" 对象可以用forEach吗？")]),r._v(" "),t("ul",[t("li",[r._v("答: 不可以 因为 foEach 方法是数组原型上的方法")]),r._v(" "),t("li",[r._v("不过可以自己封装一个 可以遍历对象的 forEach 方法")])]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[r._v("function forEach(obj, fn){\n    var key\n    if(obj instanceof Array){\n        obj.forEach(function(item, index){\n            fn(index, item)\n        })\n    }else{\n        for(key in obj){\n            fn(key, obj[key])\n        }\n    }\n}\nvar arr = [1,2,3]\nforEach(arr, function(index, item){\n    console.log(index, item)\n})\nvar obj = {x:100,y:200}\nforEach(obj, function(key, value){\n    console.log(key, value)\n})\n")])])]),t("h3",{attrs:{id:"用到过的设计模式？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用到过的设计模式？"}},[r._v("🌙")]),r._v(" 用到过的设计模式？")]),r._v(" "),t("ul",[t("li",[r._v("单例模式、工厂模式、构造函数模式")])]),r._v(" "),t("h3",{attrs:{id:"三等和两等的区别？两等比较的是什么？三等呢？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三等和两等的区别？两等比较的是什么？三等呢？"}},[r._v("🌙")]),r._v(" 三等和两等的区别？两等比较的是什么？三等呢？")]),r._v(" "),t("ul",[t("li",[r._v("==用于相对比较，===用于绝对比较，==在比较的时候可以转换数据类型（转换成相同的类型），===严格比较，只要类型不匹配就返回flase。")])]),r._v(" "),t("h3",{attrs:{id:"两个空数组相等吗？（三等、两等）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#两个空数组相等吗？（三等、两等）"}},[r._v("🌙")]),r._v(" 两个空数组相等吗？（三等、两等）")]),r._v(" "),t("p",[r._v("两等和三等都不等，他们可以toString()转化成字符串然后比较，最后相等（[]==[]  => false  []===[]  =>false   toString([])==toString([])  =>  true   toString([])===toString([])  =>  true）")]),r._v(" "),t("h3",{attrs:{id:"变量提升的理解？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变量提升的理解？"}},[r._v("🌙")]),r._v(" 变量提升的理解？")]),r._v(" "),t("ul",[t("li",[r._v("变量提升：在js代码执行之前，浏览器会对所有带var和function的进行提前的声明或者定义；")]),r._v(" "),t("li",[r._v("对带var的变量只声明不定义，变量声明后不定义其默认值是undefined")]),r._v(" "),t("li",[r._v("对带function的变量（函数名），声明并且定义")]),r._v(" "),t("li",[r._v("在普通变量赋值之前使用就是undefined，赋值之后才是具体值；而function声明的函数名在声明前使用是函数本身，在声明后使用还是函数本身")])]),r._v(" "),t("h3",{attrs:{id:"代码执行的顺序？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码执行的顺序？"}},[r._v("🌙")]),r._v(" 代码执行的顺序？")]),r._v(" "),t("ul",[t("li",[r._v("js代码执行之前，浏览器会为其开辟全局作用域，然后对全局中的变量进行提升操作，对带var和带function进行提前的声明或者定义；")]),r._v(" "),t("li",[r._v("变量提升结束后，js代码开始从上到下执行；执行的过程中对带var的变量进行赋值：\n"),t("ul",[t("li",[r._v("如果是赋值一个基本数据类型的值，那么直接把基本类型的值存在作用域中，并且把变量和值关联起来；")]),r._v(" "),t("li",[r._v("如果是赋值一个引用数据类型，浏览器会开辟一个堆内存，存储这个引用数类型的值，然后把这个堆内存的地址赋值给变量（这个时候这个内存地址是存在作用域中的）")])])]),r._v(" "),t("li",[r._v("如果执行过程遇到函数执行会经历以下几步：\n"),t("ul",[t("li",[r._v("浏览器会函数代码执行再开辟一个新的作用域（一块新的栈内存）（这解释函数每次执行都是互相独立的，因为每次执行的环境不同）")]),r._v(" "),t("li",[r._v("形参赋值，形参也是变量，把函数执行时实参赋值给形参。")]),r._v(" "),t("li",[r._v("私有作用域中的变量提升，对私有作用域中的带var和带function的提前处理（在当前作用域中变量提升）")]),r._v(" "),t("li",[r._v("从上到下执行函数代码")])])]),r._v(" "),t("li",[r._v("如果再遇到函数执行重复第三步")])]),r._v(" "),t("h3",{attrs:{id:"代码的渲染（浏览器的渲染阶段）？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码的渲染（浏览器的渲染阶段）？"}},[r._v("🌙")]),r._v(" 代码的渲染（浏览器的渲染阶段）？")]),r._v(" "),t("ul",[t("li",[r._v("解析 html 文件形成 DOM 树根据节点间关系组织树的节点关系；")]),r._v(" "),t("li",[r._v("解析 CSS 形成 CSS 树")]),r._v(" "),t("li",[r._v("把 DOM 树和 CSS 树组合形成 render 树")]),r._v(" "),t("li",[r._v("接下来交给显卡，绘制成页面")])]),r._v(" "),t("h3",{attrs:{id:"同步异步的理解？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步异步的理解？"}},[r._v("🌙")]),r._v(" 同步异步的理解？")]),r._v(" "),t("ul",[t("li",[r._v("js执行的时候，浏览器会把代码分为同步执行和异步执行任务；")]),r._v(" "),t("li",[r._v("同步任务：当前任务按顺序执行，如果当前这个任务没有完成，下一个任务不能开始；")]),r._v(" "),t("li",[r._v("异步任务：当前任务需要过一段时间或者执行时机不确定（定时器里面的回调就是过一段时间才会执行，事件就是执行时机不确定），浏览器不会傻傻的等着这件事情完成，而是先去做后面的事情，等把后面的事情都做完，再去看这些任务；")]),r._v(" "),t("li",[r._v("异步执行：定时器的回调函数、所有的事件函数、AJAX的异步情形（open的第三个参数为true就是异步执行）、回调函数也可以是异步执行")])]),r._v(" "),t("h3",{attrs:{id:"箭头函数和普通函数的区别？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数和普通函数的区别？"}},[r._v("🌙")]),r._v(" 箭头函数和普通函数的区别？")]),r._v(" "),t("ul",[t("li",[r._v("箭头函数是 ES6 新增的 箭头函数中没有 this 不可以作为构造函数")])]),r._v(" "),t("h5",{attrs:{id:"this指向问题："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this指向问题："}},[r._v("🌙")]),r._v(" this指向问题：")]),r._v(" "),t("p",[r._v("箭头函数中的this指向函数定义时所在的作用域中的this、不可以被当作构造函数、不可以使用arguments对象，该对象在函数体内不存在，如果要用就用rest参数替代、.call()/.apply()/.bind()无法改变箭头函数中this的指向、箭头函数相对于普通函数语法更简洁优雅\n普通函数指向的是它的直接调用者")]),r._v(" "),t("h4",{attrs:{id:"事件的三个阶段？（冒泡捕获触发）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件的三个阶段？（冒泡捕获触发）"}},[r._v("🌙")]),r._v(" 事件的三个阶段？（冒泡捕获触发）")]),r._v(" "),t("p",[r._v("事件的触发分为两个三个阶段：捕获阶段、目标阶段、冒泡阶段。在事件触发时，浏览器先从最外层的元素开始找，一直找到事件源的过程称为捕获阶段，触发事件源绑定事件后开始向上冒泡，依次触发父级元素的该事件；")]),r._v(" "),t("h4",{attrs:{id:"冒泡的顺序？（0级2级）ie的兼容怎么写的？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#冒泡的顺序？（0级2级）ie的兼容怎么写的？"}},[r._v("🌙")]),r._v(" 冒泡的顺序？（0级2级）IE的兼容怎么写的？")]),r._v(" "),t("p",[r._v("==DOM0级事件绑定在冒泡阶段\nDOM2级会按照绑定顺序依次触发？？？==")]),r._v(" "),t("h4",{attrs:{id:"跨域？为什么会跨域？jsonp的跨域处理？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#跨域？为什么会跨域？jsonp的跨域处理？"}},[r._v("🌙")]),r._v(" 跨域？为什么会跨域？jsonp的跨域处理？")]),r._v(" "),t("p",[r._v("1.JSONP\n2.服务端转发，因为同源策略只在客户端存在，在服务端是不存在的；所以可以由服务端转发请求；\n3.nginx 转发，nginx 是服务器应用程序，它可以接受客户端的请求，然后根据规则可以配置自动转发；\n4.CORS: Cross-Origin-Resource-Sharing: 需要目标域设置 Access-Control-Allow-Origin 头信息；\n同源策略要求通信的两个源的协议、域名、端口号要相同，如果三者中任意一个不同就是不满足同源策略；不满足同源策略的通信就是跨域；\n跨域处理：利用 script 的 src 属性是不受同源策略约束的，可以访问不同服务器或者端口号下的数据\n1.提前声明一个叫做 fn 的函数，给 fn 设置一个形参；\n2.在页面给 script 的 src 的指向的路径拼接一个 callback 属性，callback=fn；当浏览器解析到这个 script 标签时，会向 src 指向的路径发起 http 请求；\n3.服务器收到这个请求后，会返回一个 fn (这里面是服务器返回的数据)\n4.fn({xxx}) 这个是让 fn 执行，小括号里面就是服务器发送给我们的数据\njs代码：function fn(data) {\nconsole.log(data);\n}\njs代码："),t("script",{attrs:{src:"http://matchweb.sports.qq.com/kbs/calendar?columnId=100000&callback=fn"}}),r._v("\nes6？async  await\nasync / await 是 ES6 新增的关键字，用于把异步处理程序变为同步；\nasync 在函数定义时使用，用 async 函数声明的函数默认返回一个 promise 实例，返回值可以直接\n.then\nawait 右边如果是 Promise 就等着 Promise 状态发生变更，如果是同步代码直接执行；如果 await 执行的方法返回的 promise 对象，我们可以直接在对象使用 then 方法；此外，await 下面的代码都会变成微任务")]),r._v(" "),t("h4",{attrs:{id:"async和await是同步还是异步？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async和await是同步还是异步？"}},[r._v("🌙")]),r._v(" async和await是同步还是异步？")]),r._v(" "),t("p",[r._v("async是同步\nawait后面是同步的，await下面是异步的\nurl到页面发生了什么事情？\nhttp 请求阶段\n浏览器得到地址栏中的地址，发送给DNS服务器\nDNS服务器进行域名解析，找到域名对应的IP地址\n把客户端的请求发送给上一步查出来的服务器地址\nhttp 响应阶段\n服务器接收到请求后，根据请求的信息，进行资源的整理，并且把响应的资源通过http返回给客户端（数据或者html、js、css文件等）\n根据资源的类型不同，浏览器会进行不同的操作，如 html 和 css 进行解析渲染，js进行解析并执行")]),r._v(" "),t("h4",{attrs:{id:"数组去重法？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组去重法？"}},[r._v("🌙")]),r._v(" 数组去重法？")]),r._v(" "),t("p",[r._v("双for循环去重、indexOf方法去重、new set()去重、includes()去重、filter()去重、reduce()去重")]),r._v(" "),t("h4",{attrs:{id:"怎么判断一个空对象？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#怎么判断一个空对象？"}},[r._v("🌙")]),r._v(" 怎么判断一个空对象？")]),r._v(" "),t("p",[r._v("Object.getOwnPropertyNames()方法、ES6的Object.keys()方法、for in 循环判断、jquery的isEmptyObject方法")]),r._v(" "),t("h4",{attrs:{id:"权限验证？（路由拦截）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#权限验证？（路由拦截）"}},[r._v("🌙")]),r._v(" 权限验证？（路由拦截）")]),r._v(" "),t("p",[r._v("我认为最主要的便是对权限的控制,比如有的页面需要登录了才能进入,有些页面不同身份渲染不同.\n在进行路由跳转时，利用vue-router提供的钩子函数beforeEach()对路由进行判断，符合条件next()，不符合便跳转到登录页面。在发送请求时，统一处理所有http请求和响应，用上 axios 的拦截器，通过配置http resquest interceptors为http头增加Authorization字段，其内容为Token，通过配置http response interceptors对返回的数据处理。")]),r._v(" "),t("h4",{attrs:{id:"盒子模型？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#盒子模型？"}},[r._v("🌙")]),r._v(" 盒子模型？")]),r._v(" "),t("p",[r._v("通过js的方法或者属性获取的元素对象的一系列的描述盒子模型的属性\nclientWidth / clientHeight\nclientWidth 内容宽度 + 左右padding\nclientHeight 内容高度 + 上下padding\noffsetWidth / offsetHeight\noffsetWidth = clientWidth(内容宽+左右padding) + 左右边框\noffsetHeight = clientHeight(内容高+上下padding) + 上下边框\nclientLeft / clientTop\nclientLeft 左边框\nclientTop 上边框\nscroll系列\nscrollLeft(横向滚动条卷去的距离) / scrollTop(纵向滚动条卷去的距离)\n滚动条 卷去的距离，默认是0，具体是多少要看滚动条滚动了多少\n获取浏览器的窗口滚动的距离\nlet sc = document.documentElement.scrollTop || document.body.scrollTop;\nconsole.log(sc);\nscrollHeight/scrollWidth\n没有溢出时：scrollHeight/scrollWidth 等于 clientHeight/clientWidth\n内容溢出时：scrollHeight = clientHeight + 溢出内容高度;\n内容溢出时：scrollWidth= clientWidth + 溢出内容高度;\noffsetLeft / offsetTop\n父级参照物：距离当前元素最近的有定位属性的父级元素，如果没有的话默认 body；\n一般我们需要的是某个元素距离body的offsetLeft，所以就需要一级一级的向上查找")]),r._v(" "),t("h4",{attrs:{id:"工作中性能优化的方案？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工作中性能优化的方案？"}},[r._v("🌙")]),r._v(" 工作中性能优化的方案？")]),r._v(" "),t("p",[r._v("减少DNS查找、重用TCP连接、减少HTTP重定向、使用CDN（内容分发网络）、去掉不必要的资源、在客户端缓存资源、传输压缩过的内容、消除不必要的请求开销、并行处理请求和响应、针对协议版本采取优化措施：\nHTTP 1.x 支持有限的并行机制，要求打包资源、跨域分散资源，等等。相对而言，\nHTTP 2.0 只要建立一个连接就能实现最优性能，同时无需针对 HTTP 1.x 的那些优化方法。\n但是压缩、使用缓存、减少dns等的优化方案无论在哪个版本都同样适用")]),r._v(" "),t("h4",{attrs:{id:"for-of-、-for-in"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#for-of-、-for-in"}},[r._v("🌙")]),r._v(" for of  、 for in")]),r._v(" "),t("p",[r._v("for in是ES5标准，遍历key.\nfor of是ES6标准，遍历value.\n改变上下文方式？上下文是什么？\ncall、apply、bind（改变this指向）上下文是当前执行环境的作用域")]),r._v(" "),t("h4",{attrs:{id:"vue构建虚拟dom？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue构建虚拟dom？"}},[r._v("🌙")]),r._v(" vue构建虚拟DOM？")]),r._v(" "),t("h4",{attrs:{id:"虚拟dom和真实dom的区别？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom和真实dom的区别？"}},[r._v("🌙")]),r._v(" 虚拟DOM和真实DOM的区别？")]),r._v(" "),t("p",[r._v("虚拟DOM不会进行排版与重绘操作\n虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分（注意！），最后并在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘损耗\n真实DOM频繁排版与重绘的效率是相当低的\n虚拟DOM有效降低大面积（真实DOM节点）的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部")]),r._v(" "),t("h4",{attrs:{id:"vuex？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vuex？"}},[r._v("🌙")]),r._v(" Vuex？")]),r._v(" "),t("p",[r._v("Vuex是一个专门为 vue.js 应用程序开发的状态（状态就是数据）管理模式，它采用集中式存储管理应用的状态。相当于把组件中的数据提升到一个全局的地方，这个地方就是 Vuex 的 store（仓库），由 Vuex 统一管理，如果某个组件需要这个数据，直接从 store 中获取。\n如果要修改存在 Vuex 中的数据，需要在定义 store 时，定义修改这个数据的方法，这些方法称为mutation；\nmutation 函数的第一个参数是 state 对象，所有的数据都定义在 state 中，在 mutation 函数中通过 state 可以修改上面 state 中的数据")]),r._v(" "),t("h4",{attrs:{id:"数组去重：1-es6-新增set方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组去重：1-es6-新增set方法"}},[r._v("🌙")]),r._v(" 数组去重：1. ES6 新增set方法")]),r._v(" "),t("p",[r._v("var array = [1, 2, 1, 1, '1'];")]),r._v(" "),t("p",[r._v('function unique(array) {\nreturn Array.from(new Set(array));\n}\nconsole.log(unique(array)); // [1, 2, "1"]')]),r._v(" "),t("p",[r._v("可以简化成")]),r._v(" "),t("p",[r._v("function unique(array) {\nreturn [...new Set(array)];\n}")]),r._v(" "),t("h4",{attrs:{id:"_2-双for去重"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-双for去重"}},[r._v("🌙")]),r._v(" 2.双for去重")]),r._v(" "),t("p",[r._v("var array = [1, 1, '1', '1'];")]),r._v(" "),t("p",[r._v("function unique(array) {\n// res用来存储结果\nvar res = [];\nfor (var i = 0, arrayLen = array.length; i < arrayLen; i++) {\nfor (var j = 0, resLen = res.length; j < resLen; j++ ) {\nif (array[i] === res[j]) {\nbreak;\n}\n}\n// 如果array[i]是唯一的，那么执行完循环，j等于resLen\nif (j === resLen) {\nres.push(array[i])\n}\n}\nreturn res;\n}")]),r._v(" "),t("p",[r._v('console.log(unique(array)); // [1, "1"]')]),r._v(" "),t("h4",{attrs:{id:"_3-indexof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-indexof"}},[r._v("🌙")]),r._v(" 3. Indexof")]),r._v(" "),t("p",[r._v("var array = [1, 1, '1'];")]),r._v(" "),t("p",[r._v("function unique(array) {\nvar res = [];\nfor (var i = 0, len = array.length; i < len; i++) {\nvar current = array[i];\nif (res.indexOf(current) === -1) {\nres.push(current)\n}\n}\nreturn res;\n}")]),r._v(" "),t("p",[r._v("console.log(unique(array));")]),r._v(" "),t("h4",{attrs:{id:"排序-1-冒泡排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#排序-1-冒泡排序"}},[r._v("🌙")]),r._v(" 排序:1. 冒泡排序")]),r._v(" "),t("p",[r._v("function bubbleSort(arr) {\nvar len = arr.length;\nfor (var i = 0; i < len; i++) {\nfor (var j = 0; j < len - 1 - i; j++) {\nif (arr[j] > arr[j+1]) {        //相邻元素两两对比\nvar temp = arr[j+1];        //元素交换\narr[j+1] = arr[j];\narr[j] = temp;\n}\n}\n}\nreturn arr;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(bubbleSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]")]),r._v(" "),t("h4",{attrs:{id:"_2-选择排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-选择排序"}},[r._v("🌙")]),r._v(" 2. 选择排序")]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[r._v("  function selectionSort(arr) {\nvar len = arr.length;\nvar minIndex, temp;\nconsole.time('选择排序耗时');\nfor (var i = 0; i < len - 1; i++) {\n    minIndex = i;\n    for (var j = i + 1; j < len; j++) {\n        if (arr[j] < arr[minIndex]) {     //寻找最小的数\n            minIndex = j;                 //将最小数的索引保存\n        }\n    }\n    temp = arr[i];\n    arr[i] = arr[minIndex];\n    arr[minIndex] = temp;\n}\nconsole.timeEnd('选择排序耗时');\nreturn arr;\n")])])]),t("p",[r._v("}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(selectionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]")]),r._v(" "),t("h4",{attrs:{id:"_3-插入排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-插入排序"}},[r._v("🌙")]),r._v(" 3. 插入排序")]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[r._v(" function binaryInsertionSort(array) {\nif (Object.prototype.toString.call(array).slice(8, -1) === 'Array') {\n    console.time('二分插入排序耗时：');\n\n    for (var i = 1; i < array.length; i++) {\n        var key = array[i], left = 0, right = i - 1;\n        while (left <= right) {\n            var middle = parseInt((left + right) / 2);\n            if (key < array[middle]) {\n                right = middle - 1;\n            } else {\n                left = middle + 1;\n            }\n        }\n        for (var j = i - 1; j >= left; j--) {\n            array[j + 1] = array[j];\n        }\n        array[left] = key;\n    }\n    console.timeEnd('二分插入排序耗时：');\n\n    return array;\n} else {\n    return 'array is not an Array!';\n}\n")])])]),t("p",[r._v("}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(binaryInsertionSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]")]),r._v(" "),t("h4",{attrs:{id:"_4-快速排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-快速排序"}},[r._v("🌙")]),r._v(" 4. 快速排序:")]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[r._v("    function quickSort(array, left, right) {\n var length =array.length;\n left =typeof left ==='number'? left :0,\n right =typeof right ==='number'? right : length-1;\n\n    if (left < right) {\n        var index = left -1;\n        for (var i = left; i <= right; i++) {\n            if (array[i] <= array[right]) {\n                index++;\n                var temp = array[index];\n                array[index] = array[i];\n                array[i] = temp;\n            }\n        }\n        quickSort(array, left, index -1);\n        quickSort(array, index +1, right);\n    }\n    return array;\n")])])]),t("p",[r._v("}")]),r._v(" "),t("h4",{attrs:{id:"树状结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#树状结构"}},[r._v("🌙")]),r._v(" 树状结构")]),r._v(" "),t("h4",{attrs:{id:"面向对象的三大特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象的三大特性"}},[r._v("🌙")]),r._v(" 面向对象的三大特性")])])}),[],!1,null,null,null);a.default=e.exports}}]);